require 'ipaddr'


module Geolocal
  module Provider
    class Base
      def initialize params={}
        @config = params.merge(Geolocal.configuration.to_hash)
      end

      def config
        @config
      end

      def download
        # TODO: skip download if local files are new enough
        # TODO: provide a FORCE argument to force download anyway
        download_files
      end

      def update
        countries = config[:countries].merge(config[:countries]) { |name, country_codes|
          Array(country_codes).map(&:upcase).to_set
        }

        results = countries.merge(countries) { "" }

        read_ranges(countries) do |name,lo,hi|
          results[name] << "#{IPAddr.new(lo).to_i}..#{IPAddr.new(hi).to_i},\n"
        end

        File.open(config[:file], 'w') do |file|
          output(file, results)
        end

        status "done, result in #{config[:file]}\n"
      end

      def output file, results
        names = results.keys
        modname = config[:module]

        write_header file, names, modname

        file.write "module #{modname}\n"
        names.each do |name|
          write_method file, name
        end
        file.write "end\n\n"

        status "  writing "
        results.each do |name, body|
          status "#{name} "
          write_ranges file, modname, name, body
        end
        status "\n"
      end


      def write_header file, names, modname
        file.write <<EOL
# This file is autogenerated

# Defines #{names.map { |n| "#{modname}::#{n}" }.join(', ')}
#     and #{names.map { |n| "#{modname}.in_#{n}?" }.join(', ')}

EOL
      end

      def write_method file, name
        file.write <<EOL
  def self.in_#{name}? addr
    num = addr.to_i
    #{name}.bsearch { |range| num > range.max ? 1 : num < range.min ? -1 : 0 }
  end
EOL
      end

      def write_ranges file, modname, name, body
        file.write <<EOL
#{modname}::#{name} = [
#{body}]

EOL
      end
    end
  end
end


# random utilities
module Geolocal
  module Provider
    class Base
      # returns elapsed time of block in seconds
      def time_block
        start = Time.now
        yield
        stop = Time.now
        stop - start + 0.0000001 # fudge to prevent division by zero
      end

      def status *args
        unless config[:quiet]
          Kernel.print(*args)
          $stdout.flush unless args.last.end_with?("\n")
        end
      end
    end
  end
end

